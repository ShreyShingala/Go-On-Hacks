
const PLACEHOLDER_URL = "https://cdn.bap-software.net/2024/02/22165839/testdebug2.jpg";

let observer = null;
let fullScanTimer = null;
const FULL_SCAN_DEBOUNCE_MS = 80; // small debounce to batch rapid mutations
const REPLACED_CLASS = 'replaced';
const NO_PERSON_FLAG = 'noperson';
const MIN_PIXEL_AREA = 5000; // skip tiny images (w*h)

// Face detection state
let faceDetector = null;
const detectionCache = new Map();

/**
 * Initialize Chrome's Face Detection API
 */
async function initFaceDetector() {
  try {
    if (faceDetector) return faceDetector;

    // Check if Face Detection API is available
    if (!('FaceDetector' in window)) {
      console.warn('[Image Replacer] Face Detection API not available. Using fallback mode.');
      console.warn('[Image Replacer] To enable: chrome://flags/#enable-experimental-web-platform-features');
      return null;
    }

    faceDetector = new FaceDetector({ maxDetectedFaces: 5, fastMode: true });
    console.log('[Image Replacer] âœ“ Face Detection API initialized');
    return faceDetector;
  } catch (err) {
    console.error('[Image Replacer] Error initializing Face Detector:', err);
    return null;
  }
}

/**
 * Fallback: Simple heuristic to detect likely photos (when Face API unavailable)
 * Checks aspect ratio and size - photos are usually landscape/portrait rectangles
 */
function isLikelyPhoto(img) {
  try {
    const w = img.naturalWidth || img.width || 0;
    const h = img.naturalHeight || img.height || 0;
    
    if (w === 0 || h === 0) return false;
    
    const aspectRatio = w / h;
    const area = w * h;
    
    // Photos are typically:
    // - Larger than 50,000 pixels (not tiny icons)
    // - Aspect ratio between 0.5 (portrait) and 2.0 (landscape)
    // - Not extremely wide (like banners)
    const isPhotoSize = area > 50000;
    const isPhotoAspect = aspectRatio >= 0.5 && aspectRatio <= 2.0;
    
    return isPhotoSize && isPhotoAspect;
  } catch (err) {
    return false;
  }
}

/**
 * Detect if image contains a face using Chrome's native API (or fallback)
 */
async function imageContainsFace(img) {
  try {
    const detector = await initFaceDetector();
    
    // Try Face Detection API first
    if (detector) {
      const bitmap = await createImageBitmap(img);
      const faces = await detector.detect(bitmap);
      
      const hasFace = faces.length > 0;
      
      if (hasFace) {
        console.log(`[Image Replacer] Face detected in image (${faces.length} face(s)):`, img.src);
      }
      
      return hasFace;
    }
    
    // Fallback: Use heuristic detection
    const isPhoto = isLikelyPhoto(img);
    if (isPhoto) {
      console.log('[Image Replacer] Likely photo detected (fallback mode):', img.src);
    }
    return isPhoto;
    
  } catch (err) {
    console.error('[Image Replacer] Error during face detection:', err);
    // On error, fall back to heuristic
    return isLikelyPhoto(img);
  }
}

/**
 * Cached face detection to avoid re-processing the same images
 */
async function imageContainsFaceCached(img) {
  try {
    const src = img.currentSrc || img.src || '';
    if (!src) return false;

    // Return cached result if available
    if (detectionCache.has(src)) {
      return detectionCache.get(src);
    }

    // Otherwise run detection and cache result
    const hasFace = await imageContainsFace(img);
    detectionCache.set(src, hasFace);
    return hasFace;
  } catch (err) {
    console.error('[Image Replacer] Error in cached face detection:', err);
    return false;
  }
}

function isVisibleInViewport(img) {
  try {
    const rect = img.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0 && rect.bottom >= 0 && rect.right >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth);
  } catch (e) {
    return false;
  }
}

function replaceImageElement(img) {
  try {
    if (!img) return;

    // If it's already marked with the class AND already points to placeholder, skip
    const alreadyMarked = img.classList && img.classList.contains(REPLACED_CLASS);
    const isPlaceholder = (img.src === PLACEHOLDER_URL) || (img.currentSrc === PLACEHOLDER_URL);
    if (alreadyMarked && isPlaceholder) return;

    // Save originals so we can restore later
    const currentSrc = img.currentSrc || img.src || "";
    if (currentSrc) img.dataset.originalSrc = currentSrc;

    if (img.srcset) img.dataset.originalSrcset = img.srcset;
    // common lazy attributes
    if (img.dataset && img.dataset.src) img.dataset.originalDataSrc = img.dataset.src;


  // Replace sources
  try { img.src = PLACEHOLDER_URL; } catch (e) { }
  if (img.srcset) try { img.srcset = PLACEHOLDER_URL; } catch (e) { }
  if (img.dataset && img.dataset.src) img.dataset.src = PLACEHOLDER_URL;

  // Mark as replaced both with class and dataset flag (done after assignment so we can re-check later)
  try { img.classList.add(REPLACED_CLASS); } catch (e) { }
  img.dataset.replaced = 'true';

    console.log(`[Image Replacer] Replaced image: ${currentSrc || "(empty src)"} -> ${PLACEHOLDER_URL}`);
  } catch (err) {
    console.error("[Image Replacer] Error replacing image element:", err);
  }
}

function restoreImageElement(img) {
  try {
    if (!img) return;

    // Only restore those we previously changed
    const wasReplaced = img.dataset && img.dataset.replaced === 'true';
    if (!wasReplaced && !(img.classList && img.classList.contains(REPLACED_CLASS))) return;

    if (img.dataset.originalSrc !== undefined) img.src = img.dataset.originalSrc;
    if (img.dataset.originalSrcset !== undefined) img.srcset = img.dataset.originalSrcset;
    if (img.dataset.originalDataSrc !== undefined) img.dataset.src = img.dataset.originalDataSrc;

    // Clean up markers
    try { img.classList.remove(REPLACED_CLASS); } catch (e) { }
    delete img.dataset.replaced;
    delete img.dataset.originalSrc;
    delete img.dataset.originalSrcset;
    delete img.dataset.originalDataSrc;

    // also remove noperson markers if present
    try { img.classList.remove(NO_PERSON_FLAG); } catch (e) { }
    delete img.dataset[NO_PERSON_FLAG];

    console.log("[Image Replacer] Restored image to original src.");
  } catch (err) {
    console.error("[Image Replacer] Error restoring image element:", err);
  }
}

function scanAndReplace() {
  const images = Array.from(document.images || []);
  if (!images.length) {
    console.log("[Image Replacer] No images found on this page.");
    return;
  }

  // Process images intelligently: only check images without noperson flag
  images.forEach(async (img) => {
    try {
      // Skip images already replaced
      if (img.classList && img.classList.contains(REPLACED_CLASS)) return;
      
      // Skip those explicitly marked no-person (already checked, no face found)
      if (img.dataset && img.dataset[NO_PERSON_FLAG] === 'true') return;

      // Skip tiny images (icons/logos)
      const w = img.naturalWidth || img.width || 0;
      const h = img.naturalHeight || img.height || 0;
      if (w * h < MIN_PIXEL_AREA) return;

      // Only run detection for visible images to save CPU
      if (!isVisibleInViewport(img)) return;

      const hasFace = await imageContainsFaceCached(img);
      if (hasFace) {
        // Face detected = person present, replace image
        replaceImageElement(img);
      } else {
        // No face detected = mark as no-person so we don't check again
        try { img.dataset[NO_PERSON_FLAG] = 'true'; } catch (e) { }
        if (img.classList) try { img.classList.add(NO_PERSON_FLAG); } catch (e) { }
      }
    } catch (e) {
      // per-image errors should not break the scan
    }
  });

  // Also replace <source> elements inside <picture>
  const sources = Array.from(document.querySelectorAll('source'));
  sources.forEach((s) => {
    try {
      const marked = s.dataset && s.dataset.replaced === 'true';
      const isPlaceholder = s.srcset === PLACEHOLDER_URL;
      if (!marked || !isPlaceholder) {
        // save original
        if (s.srcset) s.dataset.originalSrcset = s.srcset;
        s.srcset = PLACEHOLDER_URL;
        s.dataset.replaced = 'true';
        if (s.classList) s.classList.add(REPLACED_CLASS);
        console.log('[Image Replacer] Replaced <source> srcset ->', PLACEHOLDER_URL);
      }
    } catch (e) {
      // ignore per-source errors
    }
  });

  // Replace inline background-images on elements (only inline styles to avoid touching external CSS)
  const styled = Array.from(document.querySelectorAll('[style]'));
  styled.forEach((el) => {
    try {
      const style = el.style && el.style.backgroundImage;
      if (!style || style === 'none') return;
      const marked = el.dataset && el.dataset.replaced === 'true';
      const isPlaceholder = style.includes(PLACEHOLDER_URL);
      if (!marked || !isPlaceholder) {
        // save original
        el.dataset.originalBackgroundImage = style;
        el.style.backgroundImage = `url("${PLACEHOLDER_URL}")`;
        el.dataset.replaced = 'true';
        if (el.classList) el.classList.add(REPLACED_CLASS);
        console.log('[Image Replacer] Replaced inline background-image on element ->', PLACEHOLDER_URL);
      }
    } catch (e) {
      // ignore
    }
  });
}

function scheduleFullScan() {
  if (fullScanTimer) clearTimeout(fullScanTimer);
  fullScanTimer = setTimeout(() => {
    fullScanTimer = null;
    try {
      scanAndReplace();
    } catch (e) {
      console.error('[Image Replacer] Error during full scan:', e);
    }
  }, FULL_SCAN_DEBOUNCE_MS);
}

function startObserving() {
  if (observer) return; // already observing

  // Observe added nodes and attribute changes so images added during scroll/infinite-load are replaced
  observer = new MutationObserver((mutations) => {
    let sawRelevant = false;

    for (const m of mutations) {
      if (m.type === 'childList' && m.addedNodes && m.addedNodes.length) {
        m.addedNodes.forEach((node) => {
          if (node.nodeType !== Node.ELEMENT_NODE) return;

          // If an <img> was added directly
          if (node.tagName === 'IMG') {
            scheduleFullScan();
            sawRelevant = true;
            return;
          }

          // If a subtree was added, find images inside it
          const imgs = node.querySelectorAll ? node.querySelectorAll('img') : [];
          if (imgs.length) {
            scheduleFullScan();
            sawRelevant = true;
          }
        });
      }

      // Attribute changes for lazy-loaded images that swap data-src -> src or update srcset
      if (m.type === 'attributes' && m.target && m.target.tagName === 'IMG') {
        // we'll schedule a full scan (covers attribute-based lazy loads)
        sawRelevant = true;
      }
    }

    if (sawRelevant) scheduleFullScan();
  });

  observer.observe(document.documentElement || document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ['src', 'data-src', 'srcset']
  });

  // Initial pass
  scanAndReplace();
}

function stopObservingAndRestore() {
  if (observer) {
    try {
      observer.disconnect();
    } catch (e) {
      // ignore
    }
    observer = null;
  }

  if (fullScanTimer) {
    clearTimeout(fullScanTimer);
    fullScanTimer = null;
  }

  // Restore any replaced images
  const images = Array.from(document.images || []);
  images.forEach(restoreImageElement);
}

function handleState(enabled) {
  if (enabled) {
    console.log('[Image Replacer] Enabling image replacement and observer.');
    startObserving();
  } else {
    console.log('[Image Replacer] Disabling image replacement and restoring originals.');
    stopObservingAndRestore();
  }
}

chrome.storage.sync.get({ enabled: true }, (result) => {
  handleState(Boolean(result.enabled));
});

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message?.type === "toggle-image-replacement") {
    handleState(message.enabled);
    sendResponse({ status: "ok" });
  }
});

